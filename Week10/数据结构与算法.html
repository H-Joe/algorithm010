<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>

</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@5"></script><script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.11/dist/browser/view.min.js"></script><script>((t,a,e,n)=>{const{Markmap:o,loadPlugins:s}=window.markmap;(a?a(s,e,n):Promise.resolve()).then(()=>{o.create("svg#mindmap",null,t)})})({"t":"heading","d":1,"v":"数据结构和算法","c":[{"t":"heading","d":2,"v":"1、数据结构和算法总览","c":[{"t":"list_item","d":3,"v":"<strong>I. 数据结构</strong>","c":[{"t":"list_item","d":4,"v":"一维","c":[{"t":"list_item","d":5,"v":"基础：数组 <code>array</code>（<code>string</code>）、链表 <code>linked list</code>"},{"t":"list_item","d":5,"v":"高级：栈 <code>stack</code>、队列 <code>queue</code>、双端队列 <code>deque</code>、集合 <code>set</code>、映射 <code>map</code>（<code>hash</code> or <code>map</code>），<code>etc</code>"}]},{"t":"list_item","d":4,"v":"二维","c":[{"t":"list_item","d":5,"v":"基础：树 <code>tree</code>、图 <code>graph</code>"},{"t":"list_item","d":5,"v":"高级：二叉搜索树 <code>binary search tree</code>（<code>red-black tree</code> 、<code>AVL</code>）、堆 <code>heap</code>、并查集 <code>disjoint set</code>、字典树 <code>Trie</code>，<code>etc</code>"}]},{"t":"list_item","d":4,"v":"特殊","c":[{"t":"list_item","d":5,"v":"位运算 <code>Bitwise</code>、布隆过滤器 <code>BloomFilter</code>"},{"t":"list_item","d":5,"v":"<code>LRU cache</code>"}]}]},{"t":"list_item","d":3,"v":"<strong>II. 算法</strong>","c":[{"t":"list_item","d":4,"v":"基础","c":[{"t":"list_item","d":5,"v":"<code>if-else</code>，<code>switch</code>  --> <code>branch</code> 流程控制"},{"t":"list_item","d":5,"v":"<code>for</code>, <code>while loop</code>  --> <code>Iteration</code> 迭代器"},{"t":"list_item","d":5,"v":"<code>Recursion</code> (<code>Divide &amp; Conquer</code>, <code>Backtrace</code>)递归函数"}]},{"t":"list_item","d":4,"v":"高级","c":[{"t":"list_item","d":5,"v":"搜索 <code>Search</code>：深度优先搜索 <code>Depth First Search</code>、广度优先搜索 <code>Breadth First Search</code>、启发式搜索 <code>A*</code>"},{"t":"list_item","d":5,"v":"动态规划 <code>Dynamic Programming</code>"},{"t":"list_item","d":5,"v":"二分查找 <code>Binary Search</code>"},{"t":"list_item","d":5,"v":"贪心 <code>Greedy</code>"},{"t":"list_item","d":5,"v":"数学 <code>Math</code>，几何 <code>Geometry</code>"}]}]}]},{"t":"heading","d":2,"v":"2、时空复杂度分析","c":[{"t":"bullet_list","d":3,"v":"","c":[{"t":"paragraph","d":4,"v":"<strong>I. 时间复杂度 （</strong><code><strong>Big O Notation</strong></code><strong>）</strong>"},{"t":"bullet_list","d":4,"v":"","c":[{"t":"list_item","d":5,"v":"<code>O(1)</code>：<code>Constant Complexity</code> 常数复杂度"},{"t":"list_item","d":5,"v":"<code>O(log n)</code>：<code>Logarithmic Complexity</code> 对数复杂度"},{"t":"list_item","d":5,"v":"<code>O(n)</code>：<code>Linear Complexity</code> 线性时间复杂度"},{"t":"list_item","d":5,"v":"<code>O(n^2)</code>：<code>N Square Complexity</code> 平方"},{"t":"list_item","d":5,"v":"<code>O(n^3)</code>：<code>N Cubic Complexity</code> 立方"},{"t":"list_item","d":5,"v":"<code>O(2^n)</code>：<code>Exponential Growth</code> 指数"},{"t":"list_item","d":5,"v":"<code>O(n!)</code>：<code>Factorial</code> 阶乘<br/>"}]}]},{"t":"bullet_list","d":3,"v":"","c":[{"t":"list_item","d":4,"v":"<strong>II. 主定理 （</strong><code><strong>Master Theorem</strong></code><strong>）</strong>","c":[{"t":"list_item","d":5,"v":"计算递归函数的时间复杂度","c":[{"t":"list_item","d":6,"v":"1、二分查找：有序数列找到目标数，一分为二，只查一边，所以时间复杂度为 <code>O(logn)</code>"},{"t":"list_item","d":6,"v":"2、二叉树遍历：一分为二，每一边都是相等的时间复杂度，所以时间复杂度为 <code>O(n)</code>","c":[{"t":"list_item","d":7,"v":"<strong>简化理解：每一个节点仅且访问一次</strong>"}]},{"t":"list_item","d":6,"v":"3、二维矩阵：排好序的二维矩阵进行二分查找，时间复杂度是 <code>O(n)</code>"},{"t":"list_item","d":6,"v":"4、归并排序：所有排序的最优办法的复杂度就是<code>O(nlogn)</code><br/>"}]}]},{"t":"list_item","d":4,"v":"<strong>III. 空间复杂度</strong>","c":[{"t":"list_item","d":5,"v":"数组的长度"},{"t":"list_item","d":5,"v":"递归的深度"}]},{"t":"list_item","d":4,"v":"<strong>IV. 常见数据结构时间和空间复杂度</strong>","c":[{"t":"list_item","d":5,"v":""},{"t":"list_item","d":5,"v":""}]}]}]},{"t":"heading","d":2,"v":"3、数组（Array）","c":[{"t":"list_item","d":3,"v":"<strong>I. 定义</strong>","c":[{"t":"list_item","d":4,"v":"一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。"}]},{"t":"list_item","d":3,"v":"<strong>II. 特性</strong>","c":[{"t":"list_item","d":4,"v":"访问元素快，时间复杂度是 <code>O(1)</code> 的"},{"t":"list_item","d":4,"v":"增加和删除元素时，时间复杂度平均是 <code>O(n)</code> 的（需要挪移元素）"}]},{"t":"list_item","d":3,"v":"<strong>III. 时间复杂度</strong>","c":[{"t":"bullet_list","d":4,"v":"","c":[{"t":"list_item","d":5,"v":"<code><strong>prepend</strong></code><strong>（头部拼接元素）: </strong><code><strong>O(1)</strong></code>"},{"t":"list_item","d":5,"v":"<code><strong>append</strong></code><strong>（尾部拼接元素）: </strong><code><strong>O(1)</strong></code>"},{"t":"list_item","d":5,"v":"<code><strong>lookup</strong></code><strong>（查找元素）: </strong><code><strong>O(1)</strong></code>"},{"t":"list_item","d":5,"v":"<code><strong>insert</strong></code><strong>（插入元素）: </strong><code><strong>O(n)</strong></code>"},{"t":"list_item","d":5,"v":"<code><strong>delete</strong></code><strong>（删除元素）: </strong><code><strong>O(n)</strong></code>"}]},{"t":"blockquote","d":4,"v":"","c":[{"t":"paragraph","d":5,"v":"正常情况下，<code>prepend</code>是<code>O(n)</code>的复杂度，可以采用申请稍大一些的内存空间，在数组最开始预留一部分空间，<code>prepend</code>时，把头下标前移一个位置"}]}]}]},{"t":"heading","d":2,"v":"4、链表（Linked List）","c":[{"t":"list_item","d":3,"v":"<strong>I. 概念</strong>","c":[{"t":"list_item","d":4,"v":"<code>value</code>"},{"t":"list_item","d":4,"v":"<code>next</code>：指向下一个元素"},{"t":"list_item","d":4,"v":"<code>Head</code>：头指针"},{"t":"list_item","d":4,"v":"<code>Tail</code>：尾指针<br/>"}]},{"t":"list_item","d":3,"v":"<strong>II. 特性</strong>","c":[{"t":"list_item","d":4,"v":"内存不连续"},{"t":"list_item","d":4,"v":"本身没有大小限制，支持动态扩容"}]},{"t":"list_item","d":3,"v":"<strong>III. 标准实现代码</strong>","c":[{"t":"list_item","d":4,"v":"<pre><code class=\"language-swift\">  \n  public class LinkedList {\n      var head: ListNode?\n      public class ListNode {\n          public var val: Int\n          public var next: ListNode?\n          public init(_ val: Int) {\n              self.val = val\n              self.next = nil\n          }\n      }\n  }\n</code></pre>"}]},{"t":"list_item","d":3,"v":"<strong>IV. 链表种类</strong>","c":[{"t":"list_item","d":4,"v":"单链表：只有一个 <code>next</code> 指针"},{"t":"list_item","d":4,"v":"双向链表：有 <code>next</code> 指针和 <code>previous</code> 指针"},{"t":"list_item","d":4,"v":"循环链表 ：<code>Tail</code>指针的 <code>next</code> 指向<code>Head</code>"}]},{"t":"list_item","d":3,"v":"<strong>V. 时间复杂度</strong>","c":[{"t":"list_item","d":4,"v":"<code><strong>prepend</strong></code><strong>（从头部插入节点）：</strong><code><strong>O(1)</strong></code>"},{"t":"list_item","d":4,"v":"<code><strong>append</strong></code><strong>（从尾部插入节点）：</strong><code><strong>O(1)</strong></code>"},{"t":"list_item","d":4,"v":"<code><strong>lookup</strong></code><strong>（查找节点）：</strong><code><strong>O(n)</strong></code>"},{"t":"list_item","d":4,"v":"<code><strong>insert</strong></code><strong>（插入节点）：</strong><code><strong>O(1)</strong></code>"},{"t":"list_item","d":4,"v":"<code><strong>delete</strong></code><strong>（删除节点）：</strong><code><strong>O(1)</strong></code>"}]}]},{"t":"heading","d":2,"v":"5、跳表（Skip List）","c":[{"t":"list_item","d":3,"v":"<strong>I. 特点</strong>","c":[{"t":"list_item","d":4,"v":"一种动态数据结构"},{"t":"list_item","d":4,"v":"插入、删除、搜索的时间复杂度都是<code>O(logn)</code>的数据结构"},{"t":"list_item","d":4,"v":"<strong>只能用于链表中的元素是有序的情况</strong>"},{"t":"list_item","d":4,"v":"对标的是平衡树（<code>AVL Tree</code>）和二分查找（<code>Binary Search</code>）"},{"t":"list_item","d":4,"v":"升维 + 空间换时间"}]},{"t":"list_item","d":3,"v":"<strong>II. 优势</strong>","c":[{"t":"list_item","d":4,"v":"原理简单"},{"t":"list_item","d":4,"v":"容易实现"},{"t":"list_item","d":4,"v":"方便扩展"},{"t":"list_item","d":4,"v":"效率更高"}]},{"t":"list_item","d":3,"v":"<strong>III. 缺点</strong>","c":[{"t":"list_item","d":4,"v":"增加和删除元素，导致索引不是完全工整的，有的会跨两步，有的跨多步"},{"t":"list_item","d":4,"v":"维护成本高，增加和删除元素都需要更新索引"}]},{"t":"list_item","d":3,"v":"<strong>IV. 应用</strong>","c":[{"t":"list_item","d":4,"v":"代替平衡树，如<code>Redis</code>、<code>LevelDB</code>"}]},{"t":"list_item","d":3,"v":"<strong>V. 时间复杂度和空间复杂度</strong>","c":[{"t":"list_item","d":4,"v":"<strong>时间复杂度：</strong><code><strong>O(logn)</strong></code>"},{"t":"list_item","d":4,"v":"<strong>空间复杂度：</strong><code><strong>O(n)</strong></code>"}]}]},{"t":"heading","d":2,"v":"6、栈（Stack）","c":[{"t":"list_item","d":3,"v":"<strong>I. 特点</strong>","c":[{"t":"list_item","d":4,"v":"先进后出（<code>FILO</code>）"}]},{"t":"list_item","d":3,"v":"<strong>II. 时间复杂度</strong>","c":[{"t":"list_item","d":4,"v":"<strong>添加： </strong><code><strong>O(1)</strong></code>"},{"t":"list_item","d":4,"v":"<strong>删除： </strong><code><strong>O(1)</strong></code>"},{"t":"list_item","d":4,"v":"<strong>查询： </strong><code><strong>O(n)</strong></code>"}]}]},{"t":"heading","d":2,"v":"7、队列（Queue）","c":[{"t":"list_item","d":3,"v":"<strong>I. 特点</strong>","c":[{"t":"list_item","d":4,"v":"先进先出（<code>FIFO</code>）"}]},{"t":"list_item","d":3,"v":"<strong>II. 时间复杂度</strong>","c":[{"t":"list_item","d":4,"v":"<strong>添加：</strong><code><strong>O(1)</strong></code>"},{"t":"list_item","d":4,"v":"<strong>删除：</strong><code><strong>O(1)</strong></code>"},{"t":"list_item","d":4,"v":"<strong>查询：</strong><code><strong>O(n)</strong></code>"}]},{"t":"list_item","d":3,"v":"<strong>III. 种类</strong>","c":[{"t":"list_item","d":4,"v":"<strong>双端队列（</strong><code><strong>Deque：Double-End Queue</strong></code><strong>）</strong>","c":[{"t":"list_item","d":5,"v":"特点","c":[{"t":"list_item","d":6,"v":"理解为<code>queue</code>和<code>stack</code>的集合体"},{"t":"list_item","d":6,"v":"两端可以进出的队列"},{"t":"list_item","d":6,"v":"元素没有顺序，无序的"},{"t":"list_item","d":6,"v":""}]},{"t":"list_item","d":5,"v":"<strong>时间复杂度</strong>","c":[{"t":"list_item","d":6,"v":"<strong>插入：</strong><code><strong>O(1)</strong></code>"},{"t":"list_item","d":6,"v":"<strong>删除：</strong><code><strong>O(1)</strong></code>"},{"t":"list_item","d":6,"v":"<strong>查询：</strong><code><strong>O(n)</strong></code>"}]}]},{"t":"list_item","d":4,"v":"<strong>优先队列（</strong><code><strong>Priority Queue</strong></code><strong>）</strong>","c":[{"t":"list_item","d":5,"v":"特点","c":[{"t":"list_item","d":6,"v":"顺序不在是先入先出（队列：<code>FIFO</code>）或先入后出（栈：<code>FILO</code>）"},{"t":"list_item","d":6,"v":"按照元素的优先级取出 -> <code>Vip</code>"},{"t":"list_item","d":6,"v":"底层具体实现的数据结构较为多样和复杂：<code>Heap</code>（堆）、<code>BST</code>（二叉搜索树）、<code>Treap</code>（树堆）"}]},{"t":"list_item","d":5,"v":"<strong>时间复杂度</strong>","c":[{"t":"list_item","d":6,"v":"<strong>插入：</strong><code><strong>O(1)</strong></code>"},{"t":"list_item","d":6,"v":"<strong>取出：</strong><code><strong>O(logn)</strong></code> -> 按元素的优先级取出"}]}]}]}]},{"t":"heading","d":2,"v":"8、哈希表（Hash Table）","c":[{"t":"blockquote","d":3,"v":"","c":[{"t":"paragraph","d":4,"v":"散列思想：<br/>1、散列表利用的是数组支持以 <code>O(1)</code> 复杂度通过下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。<br/>2、可以说，如果没有数组，就没有散列表。<br/>3、散列表支持插入、删除、查找"}]},{"t":"bullet_list","d":3,"v":"","c":[{"t":"list_item","d":4,"v":"<strong>I. 哈希表定义</strong>","c":[{"t":"list_item","d":5,"v":"是根据关键码值（<code>Key Value</code>）而直接进行访问的数据结构"},{"t":"list_item","d":5,"v":"它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度"},{"t":"list_item","d":5,"v":"这个映射函数称为散列函数（<code>Hash Function</code>），存放记录的数组称为哈希表，也叫散列表"}]},{"t":"list_item","d":4,"v":"<strong>II. 哈希函数(</strong><code><strong>Hash Function</strong></code><strong>)</strong>","c":[{"t":"list_item","d":5,"v":"散列函数计算得到的散列值是一个非负整数；(因为散列值要作为数组下标)"},{"t":"list_item","d":5,"v":"如果 <code>key1 == key2</code>，那 <code>hash(key1) == hash(key2)</code>"},{"t":"list_item","d":5,"v":"如果 <code>key1 != key2</code>, 那 <code>hash(key1) != hash(key2)</code>"},{"t":"list_item","d":5,"v":"散列冲突无法完全避免"}]},{"t":"list_item","d":4,"v":"<strong>III. 哈希冲突(</strong><code><strong>Hash Collisions</strong></code><strong>)</strong>","c":[{"t":"list_item","d":5,"v":"含义：通过哈希函数计算出来的值是相同的导致哈希冲突"},{"t":"list_item","d":5,"v":"解决方案","c":[{"t":"list_item","d":6,"v":"1、开放寻址法(<code>Open Addressing</code>)","c":[{"t":"list_item","d":7,"v":"重新探测一个空闲位置，将数据插入"},{"t":"list_item","d":7,"v":"优点：","c":[{"t":"list_item","d":8,"v":"1、数据全部存储在数组中，可以利用 CPU 缓存加快查询速度"},{"t":"list_item","d":8,"v":"2、容易序列化"}]},{"t":"list_item","d":7,"v":"缺点：","c":[{"t":"list_item","d":8,"v":"1、删除数据时需要特殊标记，比较麻烦"},{"t":"list_item","d":8,"v":"2、冲突的代价比较大，只适合数据量小、装载因子小的情况"}]},{"t":"list_item","d":7,"v":"装载因子","c":[{"t":"list_item","d":8,"v":"填入表中的元素个数 / 散列表的长度"},{"t":"list_item","d":8,"v":"装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降"}]}]},{"t":"list_item","d":6,"v":"2、链表法(<code>Chaining</code>) - 拉链式","c":[{"t":"list_item","d":7,"v":"升维思想"},{"t":"list_item","d":7,"v":"所有散列值相同的元素，放在此下标对应的链表中"},{"t":"list_item","d":7,"v":"优点：存取简单"},{"t":"list_item","d":7,"v":"缺点：遍历链表，做查询或删除的时间复杂度为<code>O(k)</code>，<code>k</code>为链表的长度"}]}]}]},{"t":"list_item","d":4,"v":"<strong>IV. 哈希表之</strong><code><strong>Map</strong></code>","c":[{"t":"list_item","d":5,"v":"<code>key-value</code> 对， <code>key</code>不重复"},{"t":"list_item","d":5,"v":"抽象接口，包含具体接口实现，例：<code>HashMap</code>、<code>Hashtable</code>、<code>LinkedHashMap</code>等"}]},{"t":"list_item","d":4,"v":"<strong>V. 哈希表之</strong><code><strong>Set</strong></code>","c":[{"t":"list_item","d":5,"v":"单元素，不重复元素的集合"},{"t":"list_item","d":5,"v":"抽象接口，包含好多具体接口实现，例：<code>HashSet</code>、<code>EnumSet</code>、<code>ConcurrentSkipListSet</code>等"}]}]}]},{"t":"heading","d":2,"v":"9、树（Tree）","c":[{"t":"list_item","d":3,"v":"<strong>I. 基本定义</strong>","c":[{"t":"list_item","d":4,"v":"每个元素称为节点"},{"t":"list_item","d":4,"v":"有根节点，左节点，右节点，兄弟节点"},{"t":"list_item","d":4,"v":"左子树，右子树"},{"t":"list_item","d":4,"v":"层"}]},{"t":"list_item","d":3,"v":"<strong>II. 特殊关系</strong>","c":[{"t":"list_item","d":4,"v":"<strong>链表（</strong><code><strong>Linked List</strong></code><strong>）是特殊化的树（</strong><code><strong>Tree</strong></code><strong>）</strong>"},{"t":"list_item","d":4,"v":"<strong>树（</strong><code><strong>Tree</strong></code><strong>）是特殊化的图（</strong><code><strong>Graph</strong></code><strong>）</strong>"}]},{"t":"list_item","d":3,"v":"<strong>III. 二叉树（</strong><code><strong>Binary Tree</strong></code><strong>）</strong>","c":[{"t":"list_item","d":4,"v":"定义：子节点只有两个节点：左节点和右节点的树"},{"t":"list_item","d":4,"v":"种类：","c":[{"t":"list_item","d":5,"v":"满二叉树","c":[{"t":"list_item","d":6,"v":"除最后一层无任何子节点外，每一层上的所有结点都有两个子结点"}]},{"t":"list_item","d":5,"v":"完全二叉树","c":[{"t":"list_item","d":6,"v":"除了最后一层外，其他层的节点个数都是满的"},{"t":"list_item","d":6,"v":"最后一层的叶子节点都靠左排列"},{"t":"list_item","d":6,"v":"<strong>满二叉树一定是完全二叉树</strong>"}]}]},{"t":"list_item","d":4,"v":"遍历","c":[{"t":"list_item","d":5,"v":"前序（<code>Pre-order</code>）：根 - 左 - 右","c":[{"t":"list_item","d":6,"v":"示例代码"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">  func preOrder(_ root: TreeNode?) {\n      if root != nil {\n          print(root.val)\n          preorder(root.left)\n          preorder(root.right)\n      }\n  }\n</code></pre>"}]},{"t":"list_item","d":5,"v":"中序（<code>In-order</code>）：左 - 根 - 右","c":[{"t":"list_item","d":6,"v":"示例代码"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">  func inOrder(_ root: TreeNode?) {\n      if root != nil {\n          preorder(root.left)\n          print(root.val)\n          preorder(root.right)\n      }\n  }\n</code></pre>"}]},{"t":"list_item","d":5,"v":"后序（<code>Post-order</code>）：左 - 右 - 根","c":[{"t":"list_item","d":6,"v":"示例代码"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">  func postOrder(_ root: TreeNode?) {\n      if root != nil {\n          preorder(root.left)\n          preorder(root.right)\n          print(root.val)\n      }\n  }\n</code></pre>"}]},{"t":"list_item","d":5,"v":"层序","c":[{"t":"list_item","d":6,"v":"借助队列辅助"},{"t":"list_item","d":6,"v":"根节点入队，然后从队列取出一个节点处理，将该节点的左右子节点依次入队，然后处理下一个节点，直到队列为空。"}]}]}]},{"t":"list_item","d":3,"v":"<strong>IV. 二叉搜索树（</strong><code><strong>Binary Search Tree</strong></code><strong>）</strong>","c":[{"t":"list_item","d":4,"v":"定义：一颗空树，具有下列性质的二叉树","c":[{"t":"list_item","d":5,"v":"左子树上的<strong>所有节点</strong>的值均<strong>小于</strong>它的<strong>根节点</strong>的值"},{"t":"list_item","d":5,"v":"右子树上的<strong>所有节点</strong>的值均<strong>大于</strong>它的<strong>根节点</strong>的值"},{"t":"list_item","d":5,"v":"以此类推：左、右子树也分别是二叉查询树"}]},{"t":"list_item","d":4,"v":"是<strong>有序树</strong>，所以中序遍历是一个升序排列"},{"t":"list_item","d":4,"v":"<strong>常见操作： 时间复杂度都是</strong><code><strong>O(logn)</strong></code>","c":[{"t":"list_item","d":5,"v":"<strong>查询</strong>"},{"t":"list_item","d":5,"v":"<strong>插入新节点（创建）</strong>"},{"t":"list_item","d":5,"v":"<strong>删除</strong>"}]}]}]},{"t":"heading","d":2,"v":"10、堆（Heap）","c":[{"t":"list_item","d":3,"v":"<strong>I. 定义</strong>","c":[{"t":"list_item","d":4,"v":"可以迅速找到一堆数中的最大值或最小值的数据结构"}]},{"t":"list_item","d":3,"v":"<strong>II. 分类</strong>","c":[{"t":"list_item","d":4,"v":"大顶堆（大根堆）：根节点的值是最大的"},{"t":"list_item","d":4,"v":"小顶堆（小根堆）：根节点的值是最小的"},{"t":"list_item","d":4,"v":"常见的堆：二叉堆、斐波那契堆等"}]},{"t":"list_item","d":3,"v":"<strong>III. 常见操作（</strong><code><strong>API</strong></code><strong>）- 以大顶堆为例</strong>","c":[{"t":"list_item","d":4,"v":"<code><strong>find-max</strong></code><strong>： 时间复杂度 </strong><code><strong>O(1)</strong></code>"},{"t":"list_item","d":4,"v":"<code><strong>delete-max</strong></code><strong>：时间复杂度 </strong><code><strong>O(logn)</strong></code>"},{"t":"list_item","d":4,"v":"<code><strong>insert(create)</strong></code><strong>：时间复杂度 </strong><code><strong>O(logn)</strong></code><strong> or </strong><code><strong>O(1)</strong></code><br/>"}]},{"t":"list_item","d":3,"v":"<strong>IV. 二叉堆（</strong><code><strong>Binary Heap</strong></code><strong>）</strong>","c":[{"t":"blockquote","d":4,"v":"","c":[{"t":"paragraph","d":5,"v":"二叉堆是堆的一种常见且简单的实现，但并不是最优的实现"}]},{"t":"bullet_list","d":4,"v":"","c":[{"t":"list_item","d":5,"v":"实现方式：通过完全二叉树实现，不是二叉搜索树"},{"t":"list_item","d":5,"v":"性质：以大顶堆为例","c":[{"t":"list_item","d":6,"v":"1、是一颗完全树"},{"t":"list_item","d":6,"v":"2、树中任意节点的值总是 >= 其子节点的值"}]},{"t":"list_item","d":5,"v":"实现细节","c":[{"t":"list_item","d":6,"v":"1、一般通过“数组”实现，那么堆顶元素（根节点）是数组第一个元素: <code>a[0]</code>"},{"t":"list_item","d":6,"v":"2、假设“第一个元素”在数组中的索引为<code>0</code>的话，那父节点和子节点的关系如下：","c":[{"t":"list_item","d":7,"v":"索引为 <code>i</code> 的左节点的索引为：<code>2*i+1</code>"},{"t":"list_item","d":7,"v":"索引为 <code>i</code> 的右节点的索引为：<code>2*i+2</code>"},{"t":"list_item","d":7,"v":"索引为 <code>i</code> 的父节点的索引为：<code>floor((i-1)/2)</code>"}]}]},{"t":"list_item","d":5,"v":"常见操作（<code>API</code>）","c":[{"t":"list_item","d":6,"v":"<code><strong>insert</strong></code>","c":[{"t":"list_item","d":7,"v":"1、新元素一律插入到堆的尾部"},{"t":"list_item","d":7,"v":"2、依次向上调整整个堆的结构，一直到根节点"},{"t":"list_item","d":7,"v":"函数称为：<code><strong>HeapifyUp</strong></code>"},{"t":"list_item","d":7,"v":"<pre><code class=\"language-java\">/**\n * Inserts new element in to heap\n * Complexity: O(log N)\n * As worst case scenario, we need to traverse till the root\n */\npublic void insert(int x) {\n    if (isFull()) {\n        throw new NoSuchElementException(&quot;Heap is full, No space to insert new element&quot;);\n    }\n    heap[heapSize] = x;\n    heapSize ++;\n    heapifyUp(heapSize - 1);\n}\n\n/**\n  Maintains the heap property while inserting an element.\n */\nprivate void heapifyUp(int i) {\n    int insertValue = heap[i];\n    while (i > 0 &amp;&amp; insertValue > heap[parent(i)]) {\n        heap[i] = heap[parent(i)];\n        i = parent(i);\n    }\n    heap[i] = insertValue;\n}\n</code></pre>"}]},{"t":"list_item","d":6,"v":"<code><strong>delete Max</strong></code>","c":[{"t":"list_item","d":7,"v":"1、将堆尾元素替换到顶部（堆顶被替代删除掉）"},{"t":"list_item","d":7,"v":"2、依次从根部向下调整整个堆的结构，一直到堆尾即可"},{"t":"list_item","d":7,"v":"函数称为：<code><strong>HeapifyDown</strong></code>"},{"t":"list_item","d":7,"v":"<pre><code class=\"language-java\">  /**\n   * Deletes element at index x\n   * Complexity: O(log N)\n   */\n  public int delete(int x) {\n      if (isEmpty()) {\n          throw new NoSuchElementException(&quot;Heap is empty, No element to delete&quot;);\n      }\n      int maxElement = heap[x];\n      heap[x] = heap[heapSize - 1];\n      heapSize--;\n      heapifyDown(x);\n      return maxElement;\n  }\n  /**\n   * Maintains the heap property while deleting an element.\n   */\n  private void heapifyDown(int i) {\n      int child;\n      int temp = heap[i];\n      while (kthChild(i, 1) &lt; heapSize) {\n          child = maxChild(i);\n          if (temp >= heap[child]) {\n              break;\n          }\n          heap[i] = heap[child];\n          i = child;\n      }\n      heap[i] = temp;\n  }\n</code></pre>"}]}]}]}]}]},{"t":"heading","d":2,"v":"11、图（Graph）","c":[{"t":"bullet_list","d":3,"v":"","c":[{"t":"list_item","d":4,"v":"<strong>I. 定义</strong>","c":[{"t":"list_item","d":5,"v":"<code>Graph(V, E)</code> ，由一些顶点和边对象组成的数据结构"}]},{"t":"list_item","d":4,"v":"<strong>II. 属性</strong>","c":[{"t":"list_item","d":5,"v":"<code>V</code> - <code>vertex</code>：点","c":[{"t":"list_item","d":6,"v":"1、度：入度和出度"},{"t":"list_item","d":6,"v":"2、点与点之间连通与否"}]},{"t":"list_item","d":5,"v":"<code>E</code> - <code>edge</code>： 边","c":[{"t":"list_item","d":6,"v":"1、有向和无向（单行线）"},{"t":"list_item","d":6,"v":"2、权重（边长）"}]}]},{"t":"list_item","d":4,"v":"<strong>III. 分类</strong>","c":[{"t":"list_item","d":5,"v":"无向无权图"},{"t":"list_item","d":5,"v":"无向有权图"},{"t":"list_item","d":5,"v":"有向无权图"},{"t":"list_item","d":5,"v":"有向有权图"}]},{"t":"list_item","d":4,"v":"<strong>IV. 表示</strong>","c":[{"t":"list_item","d":5,"v":"邻接矩阵（<code>Adjacency matrix</code>）"},{"t":"list_item","d":5,"v":""},{"t":"list_item","d":5,"v":"邻接表（<code>Adjacency list</code>）"},{"t":"list_item","d":5,"v":""},{"t":"list_item","d":5,"v":"<strong>时间复杂度</strong>"},{"t":"list_item","d":5,"v":""}]}]},{"t":"bullet_list","d":3,"v":"","c":[{"t":"paragraph","d":4,"v":"<strong>V. 基于图的常见算法</strong>"},{"t":"bullet_list","d":4,"v":"","c":[{"t":"list_item","d":5,"v":"<code>DFS</code>：深度优先搜索","c":[{"t":"list_item","d":6,"v":"递归代码模版"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-C++\">visited = set() #和树中的dfs最大的区别\ndef dfs(node, visited):\n    if node in visited\n        # already visited\n        return\n    visited add(node)\n    \n    # process current node here \n    process(node)\n    ...\n    \n    for next_node in node.childred():\n        if not next_node in visited:\n            dfs(next_node, visited)\n</code></pre>"}]},{"t":"list_item","d":5,"v":"<code>BFS</code>：广度优先搜索","c":[{"t":"list_item","d":6,"v":"递归代码模版"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-C++\">def bfs(graph, start, end):\n    queue = []\n    queue.append([start])\n    \n    visited = set() # 和树中的bfs最大的区别\n    \n    while queue:\n        node = queue.pop()\n        visited.add(node)\n        \n        # process current node here\n        process(node)\n        \n        nodes = generate_related_nodes(node)\n        queue.push(nodes)\n    \n</code></pre>"}]}]}]}]},{"t":"heading","d":2,"v":"12、递归（Recursion）","c":[{"t":"list_item","d":3,"v":"<strong>I. 定义</strong>","c":[{"t":"list_item","d":4,"v":"通过函数体进行的循环"}]},{"t":"list_item","d":3,"v":"<strong>II. 特点</strong>","c":[{"t":"list_item","d":4,"v":"向下进入不同层，向上回到原来的层"},{"t":"list_item","d":4,"v":"达到循环终止条件，回到上一层"},{"t":"list_item","d":4,"v":"每一层携带的变量"}]},{"t":"list_item","d":3,"v":"<strong>III. 递归模版</strong>","c":[{"t":"list_item","d":4,"v":"<pre><code class=\"language-swift\"> func recursion(level: Int, param: Int) {\n     \n     /// 1、recursion terminator\n     if level > MAX_LEVEL {\n         /// process result\n         return \n     }\n         \n     /// 2、 process current logic\n     process(level, param)\n         \n     /// 3、drill down\n     recursion(level: level + 1, newParam)\n         \n     /// 4、reverse current status if needed\n }\n</code></pre>"}]},{"t":"list_item","d":3,"v":"<strong>IV. 思维要点</strong>","c":[{"t":"list_item","d":4,"v":"1、不要人肉递归"},{"t":"list_item","d":4,"v":"2、找到最近最简方法，将其拆分成可重复解决的问题（重复子问题）"},{"t":"list_item","d":4,"v":"3、数学归纳法思维"}]}]},{"t":"heading","d":2,"v":"13、分治（Divid &amp; Conquer）","c":[{"t":"list_item","d":3,"v":"<strong>I. 特点</strong>","c":[{"t":"list_item","d":4,"v":"分解问题，组合子问题的结果 （split and merge）"}]},{"t":"list_item","d":3,"v":"<strong>II. 代码模版：</strong>","c":[{"t":"list_item","d":4,"v":"<pre><code class=\"language-swift\">  func divide_conquer(problem: Any, param1: Any, ...) {\n      /// 1、recursion terminator\n      if problem == nil {\n          /// print result\n          return \n      }         \n  \n      /// 2、prepare data （process）\n      var data = prepare_data(problem)\n      var subProblems = split_problem(problem, data)\n      \n      /// 3、conquer subproblems （drill down）\n      var subResult1 = divide_conquer(subProblem[0], newParam1, ...)\n      var subResult2 = divide_conquer(subProblem[1], newParam1, ...)\n      \n      /// 4、process and generated the final  result （merge）\n      var result = process_result(subResult1, subResult2, ...)\n      \n      /// 5、reverse the current level states\n      \n  }\n</code></pre>"}]}]},{"t":"heading","d":2,"v":"14、回溯 （Backtracking）","c":[{"t":"list_item","d":3,"v":"<strong>I. 定义</strong>","c":[{"t":"list_item","d":4,"v":"尝试分布解决问题，当现有的分布答案不能得到有效的正确的答案时，将取消上一步，甚至上几步的计算，再通过其他的分布解答中，找到问题的答案"}]},{"t":"list_item","d":3,"v":"<strong>II. 实现方法</strong>：通过递归方法实现"},{"t":"list_item","d":3,"v":"<strong>III. 时间复杂度</strong>： 在最坏的情况下，是指数时间的复杂度"}]},{"t":"heading","d":2,"v":"15、搜索（Search）","c":[{"t":"list_item","d":3,"v":"<strong>I. 搜索（遍历）</strong>","c":[{"t":"list_item","d":4,"v":"每个节点都要访问"},{"t":"list_item","d":4,"v":"每个节点只访问一次"},{"t":"list_item","d":4,"v":"对节点的访问顺序不限","c":[{"t":"list_item","d":5,"v":"深度优先（<code>DFS</code>）：<code>depth first search</code>"},{"t":"list_item","d":5,"v":"广度优先（<code>BFS</code>）：<code>breadth first search</code>"},{"t":"list_item","d":5,"v":"优先级优先：启发式搜索 <code>A*</code>"}]}]},{"t":"list_item","d":3,"v":"<strong>II. 深度优先搜索（</strong><code><strong>DFS</strong></code><strong>）</strong>","c":[{"t":"list_item","d":4,"v":"代码模版","c":[{"t":"list_item","d":5,"v":"递归写法","c":[{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\"> var visited = Set()\n func DFS(node, visited) {\n     /// 1、terminator\n     if visited.contains(node) {\n         /// already visited\n         return \n     }\n     visited.add(node)\n     \n     /// 2、process current node here\n     \n     /// 3、drill down\n     /// N叉树\n     for nextNode in node.children() {\n         if !visited.contains(nextNode) {\n             DFS(nextNode, visited)\n         }\n     }\n     \n     ///二叉树\n     DFS(node.left, visited)\n     DFS(node.right, visited)\n }\n\n</code></pre>"}]},{"t":"list_item","d":5,"v":"非递归写法","c":[{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">func DFS(tree) {\n    if !tree.root {\n        return []\n    }\n    \n    var stack = [TreeNode]()\n    stack.append(tree.root)\n    var visited = []()\n    \n    while !stack.isEmpty {\n        let node = stack.popLast()\n        visited.append(node)\n        \n        process(node)\n        \n        let nodes = generate_related_nodes(node)\n        stack.append(nodes)\n    }\n    \n    /// other process work\n}\n\n</code></pre>"}]}]}]},{"t":"list_item","d":3,"v":"<strong>III. 广度优先搜索（</strong><code><strong>BFS</strong></code><strong>）</strong>","c":[{"t":"list_item","d":4,"v":"代码模版","c":[{"t":"list_item","d":5,"v":"<pre><code class=\"language-swift\">  func BFS(graph, start, end) {\n      var visited = Set()\n      var queue = []()\n      queue.append(start)\n      \n      while !queue.isEmpty {\n          let node = queue.removeFirst()\n          visited.append(node)\n          \n          process(node)\n          \n          var nodes = generate_related_nodes(node)\n          queue.append(nodes)\n      }\n      \n      /// other process work\n  \n  }\n</code></pre>"}]}]}]},{"t":"heading","d":2,"v":"16、贪心算法（Greedy）","c":[{"t":"list_item","d":3,"v":"<strong>I. 定义</strong>","c":[{"t":"bullet_list","d":4,"v":"","c":[{"t":"paragraph","d":5,"v":"贪心算法是一种在每一步选择中都采取当前状态下最好或最优（即最有利）的选择， 从而希望导致结果是全局最好或最优的算法"}]},{"t":"blockquote","d":4,"v":"","c":[{"t":"paragraph","d":5,"v":"贪心算法和动态规划的不同之处：<br/>1、贪心算法对每个子问题的解决方案都作出选择，不能回退 --> <strong>当下最做局部最优判断</strong><br/>2、动态规划会保存以前的计算结果，并根据以前的结果对当前进行选择，有回退功能 --> <strong>最优判断 + 回退</strong>"}]}]},{"t":"list_item","d":3,"v":"<strong>II. 适用场景</strong>","c":[{"t":"list_item","d":4,"v":"最优子结构","c":[{"t":"list_item","d":5,"v":"问题分解成子问题来解决，子问题的最优解能够递推到最终问题的最优解"}]}]}]},{"t":"heading","d":2,"v":"17、二分查找 （Binary Search）","c":[{"t":"list_item","d":3,"v":"<strong>I. 二分查找前提</strong>","c":[{"t":"list_item","d":4,"v":"1、<strong>目标函数单调性（单调递增或单调递减）</strong>"},{"t":"list_item","d":4,"v":"2、存在上下界（<code>bounded</code>）"},{"t":"list_item","d":4,"v":"3、能够通过索引访问（<code>index accessible</code>）"}]},{"t":"list_item","d":3,"v":"<strong>II. 代码模版</strong>","c":[{"t":"list_item","d":4,"v":"<pre><code class=\"language-swift\">\n  var left = 0, right = array.count - 1, mid = 0\n  while left &lt;= right {\n      mid = (left + right) / 2\n      if array[mid] ==  target {\n          /// find the target \n          return result\n      }else if array[mid] > target {\n          right = mid - 1\n      }else {\n          left = mid + 1\n      }\n  }\n</code></pre>"}]}]},{"t":"heading","d":2,"v":"18、动态规划 （Dynamic Programming）","c":[{"t":"list_item","d":3,"v":"<strong>I. 定义</strong>","c":[{"t":"list_item","d":4,"v":"&quot;Simplifying a complicated problem by breaking it down into simpler sub-problems&quot; (in a recursive manner)"},{"t":"list_item","d":4,"v":"Divide &amp; Conquer（分治） + Optimal substructure（最优子结构）"}]},{"t":"list_item","d":3,"v":"<strong>II. 关键点</strong>","c":[{"t":"list_item","d":4,"v":"动态规划和 递归或分治 没有根本上的区别（关键看有无最优子结构）"},{"t":"list_item","d":4,"v":"<strong>共性：找到重复子问题</strong>"},{"t":"list_item","d":4,"v":"差异性：<code>DP</code>有最优子结构，中途可以<strong>淘汰</strong>次优解"}]},{"t":"list_item","d":3,"v":"<strong>III. 理解</strong>","c":[{"t":"list_item","d":4,"v":"和分治有内在的联系，是无法完全割裂的两个算法"},{"t":"list_item","d":4,"v":"和分治的区别：","c":[{"t":"list_item","d":5,"v":"<code>DP</code>存在最优子结构 -> 在中间的每一步不需要把所有的状态都保留下来，只需要保存最优的状态"},{"t":"list_item","d":5,"v":"前提：能证明每一步最优的值能推导出全局最优的值"}]},{"t":"list_item","d":4,"v":"缓存：状态的存储数组"},{"t":"list_item","d":4,"v":"淘汰次优解：在每一步都会把次优状态淘汰，只保留在这一步中最优或较优的状态，来推导出最后的全局最优"}]},{"t":"list_item","d":3,"v":"<strong>IV. 程序关键点</strong>","c":[{"t":"list_item","d":4,"v":"1、最优子结构："},{"t":"list_item","d":4,"v":"2、存储中间状态："},{"t":"list_item","d":4,"v":"3、递推公式（状态转移方程式或DP方程）："}]}]},{"t":"heading","d":2,"v":"19、字典树（Trie）","c":[{"t":"list_item","d":3,"v":"<strong>I. 数据结构</strong>","c":[{"t":"list_item","d":4,"v":"是一种树形结构，即Trie树，又称单词查找树或键树"},{"t":"list_item","d":4,"v":"典型应用于统计和排序大量的字符串（但又不限于字符串），经常被搜索引擎系统用于文本词频统计"},{"t":"list_item","d":4,"v":"优点：最大限度的减少无谓的字符串比较，查询效率比哈希表高"},{"t":"list_item","d":4,"v":""}]},{"t":"list_item","d":3,"v":"<strong>II. 核心思想</strong>","c":[{"t":"list_item","d":4,"v":"核心思想是用空间换时间"},{"t":"list_item","d":4,"v":"利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的"}]},{"t":"list_item","d":3,"v":"<strong>III. 基本性质</strong>","c":[{"t":"list_item","d":4,"v":"1、结点本身不存完整单词"},{"t":"list_item","d":4,"v":"2、从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串"},{"t":"list_item","d":4,"v":"3、每个结点的所有子结点路径代表的字符都不相同"},{"t":"list_item","d":4,"v":""}]},{"t":"list_item","d":3,"v":"<strong>IV. 与其他数据结构对比</strong>","c":[{"t":"list_item","d":4,"v":"哈希表可以在 <code>O(1)</code> 时间内寻找键值，却无法高效的完成 1、找到具有同一前缀的全部键值 2、按词典序枚举字符串的数据集"},{"t":"list_item","d":4,"v":"随着哈希表大小增加，会出现大量的冲突，时间复杂度可能增加到 <code>O(n)</code>，其中 <code>n</code> 是插入的键的数量"},{"t":"list_item","d":4,"v":"<code>Trie</code> 树在存储多个具有相同前缀的键时可以使用较少的空间。此时 <code>Trie</code> 树只需要 <code>O(m)</code> 的时间复杂度，其中 <code>m</code> 为键长"},{"t":"list_item","d":4,"v":"平衡树中查找键值需要 <code>O(mlogn)</code> 时间复杂度"}]},{"t":"list_item","d":3,"v":"<strong>V. 代码模版</strong>","c":[{"t":"list_item","d":4,"v":"Swift实现"},{"t":"list_item","d":4,"v":"<pre><code class=\"language-swift\">  class Trie {\n      static let R = 26\n      static let aSVal = Int(Character(&quot;a&quot;).asciiValue ?? 97)\n  \n      class TrieNode {\n          var root = [TrieNode?](repeating: nil, count: R)\n          var isEnd = false \n          init(){}\n          func containsKey(_ char: Character) -> Bool {\n              guard let _ = root[Int(char.asciiValue!) - aSVal] else { return false }\n              return true\n          }\n          func put(_ char: Character, _ node: TrieNode?) {\n              guard let targetASval = char.asciiValue else { return }\n              root[Int(targetASval) - aSVal] = node\n          }\n          func get(_ char: Character) -> TrieNode? {\n              guard let target = root[Int(char.asciiValue!) - aSVal] else { return nil }\n              return target\n          }\n      }\n  \n      var root = TrieNode()\n      /** Initialize your data structure here. */\n      init() {\n  \n      }\n      \n      /// O(m) O(m)\n      /** Inserts a word into the trie. */\n      func insert(_ word: String) {\n          guard !word.isEmpty else { return }\n          var node = root\n          for c in word {\n              if !node.containsKey(c) { node.put(c, TrieNode()) }\n              node = node.get(c)!\n          }\n          node.isEnd = true\n      }\n      \n      /// O(m) O(1)\n      /** Returns if the word is in the trie. */\n      func search(_ word: String) -> Bool {\n          guard !word.isEmpty else { return false }\n          var node = root \n          for c in word {\n              if !node.containsKey(c) { return false }\n              node = node.get(c)!\n          }\n          return node.isEnd\n      }\n       /// O(m) O(1)\n      /** Returns if there is any word in the trie that starts with the given prefix. */\n      func startsWith(_ prefix: String) -> Bool {\n          guard !prefix.isEmpty else { return false }\n          var node = root\n          for c in prefix {\n              if !node.containsKey(c) { return false }\n              node = node.get(c)!\n          }\n          return true \n      }\n  }\n</code></pre>"},{"t":"list_item","d":4,"v":"Python实现"},{"t":"list_item","d":4,"v":"<pre><code class=\"language-python\">  class Trie(object):\n          def __init__(self): \n              self.root = {} \n              self.end_of_word = &quot;#&quot; \n       \n          def insert(self, word): \n              node = self.root \n              for char in word: \n                  node = node.setdefault(char, {}) \n              node[self.end_of_word] = self.end_of_word \n       \n          def search(self, word): \n              node = self.root \n              for char in word: \n                  if char not in node: \n                      return False \n                  node = node[char] \n              return self.end_of_word in node \n       \n          def startsWith(self, prefix): \n              node = self.root \n              for char in prefix: \n                  if char not in node: \n                      return False \n                  node = node[char] \n              return True\n</code></pre>"},{"t":"list_item","d":4,"v":"C++ 实现"},{"t":"list_item","d":4,"v":"<pre><code class=\"language-cpp\">  class Trie {\n      struct TrieNode {\n          map&lt;char, TrieNode*>child_table;\n          int end;\n          TrieNode(): end(0) {}\n      };\n          \n      public:\n      /** Initialize your data structure here. */\n      Trie() {\n          root = new TrieNode();\n      }\n      \n      /** Inserts a word into the trie. */\n      void insert(string word) {\n          TrieNode *curr = root;\n          for (int i = 0; i &lt; word.size(); i++) {\n              if (curr->child_table.count(word[i]) == 0)\n                  curr->child_table[word[i]] = new TrieNode();\n                  \n              curr = curr->child_table[word[i]];                \n          }\n          curr->end = 1;\n      }\n      \n      /** Returns if the word is in the trie. */\n      bool search(string word) {\n          return find(word, 1);\n      }\n      \n      /** Returns if there is any word in the trie that starts with the given prefix. */\n      bool startsWith(string prefix) {\n          return find(prefix, 0);\n      }\n      private:\n      TrieNode* root;\n      bool find(string s, int exact_match) {\n          TrieNode *curr = root;\n          for (int i = 0; i &lt; s.size(); i++) {\n              if (curr->child_table.count(s[i]) == 0)\n                  return false;\n              else\n                  curr = curr->child_table[s[i]];\n          }\n          \n          if (exact_match)\n              return (curr->end) ? true : false;\n          else\n              return true;\n      }\n  }\n</code></pre>"},{"t":"list_item","d":4,"v":"Java 实现"},{"t":"list_item","d":4,"v":"<pre><code class=\"language-java\">  class Trie {\n      private boolean isEnd;\n      private Trie[] next;\n      /** Initialize your data structure here. */\n      public Trie() {\n          isEnd = false;\n          next = new Trie[26];\n      }\n      \n      /** Inserts a word into the trie. */\n      public void insert(String word) {\n          if (word == null || word.length() == 0) return;\n          Trie curr = this;\n          char[] words = word.toCharArray();\n          for (int i = 0;i &lt; words.length;i++) {\n              int n = words[i] - 'a';\n              if (curr.next[n] == null) curr.next[n] = new Trie();\n              curr = curr.next[n];\n          }\n          curr.isEnd = true;\n      }\n      \n      /** Returns if the word is in the trie. */\n      public boolean search(String word) {\n          Trie node = searchPrefix(word);\n          return node != null &amp;&amp; node.isEnd;\n      }\n      \n      /** Returns if there is any word in the trie that starts with the given prefix. */\n      public boolean startsWith(String prefix) {\n          Trie node = searchPrefix(prefix);\n          return node != null;\n      }\n  \n      private Trie searchPrefix(String word) {\n          Trie node = this;\n          char[] words = word.toCharArray();\n          for (int i = 0;i &lt; words.length;i++) {\n              node = node.next[words[i] - 'a'];\n              if (node == null) return null;\n          }\n          return node;\n      }\n  }\n</code></pre>"}]}]},{"t":"heading","d":2,"v":"20、并查集 （Disjoint Set）","c":[{"t":"list_item","d":3,"v":"<strong>I. 适用场景</strong>","c":[{"t":"list_item","d":4,"v":"组团、配对问题"}]},{"t":"list_item","d":3,"v":"<strong>II. 基本操作</strong>","c":[{"t":"list_item","d":4,"v":"<code>makeSet(s)</code>: 建立一个新的并查集，其中包含s个单元素集合"},{"t":"list_item","d":4,"v":"<code>unionSet(x, y)</code>: 把元素x和元素y所在的集合合并，要求x和y所在的集合不相交， 如果相交则不合并"},{"t":"list_item","d":4,"v":"<code>find(x)</code>: 找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将他们各自的代表比较一下即可"}]},{"t":"list_item","d":3,"v":"<strong>III. 原理</strong>","c":[{"t":"list_item","d":4,"v":"1、初始化：每个元素初始化一个parent数组指向自己"},{"t":"list_item","d":4,"v":"2、合并：找到各自集合的领头元素（parent==自己），然后将其中一个的集合的parent指向另一个集合的领头元素<br/><br/>"},{"t":"list_item","d":4,"v":"3、查询：找到集合的领头元素（parent==自己）"}]},{"t":"list_item","d":3,"v":"<strong>IV. 代码实现</strong>","c":[{"t":"list_item","d":4,"v":"Swift 实现"},{"t":"list_item","d":4,"v":"<pre><code class=\"language-swift\">  class UnionFind {\n      var count = 0\n      var p: [Int]\n      var size: [Int]\n      init(_ count: Int){\n          self.count = count\n          p = [Int](repeating: 0, count: count)\n          size = [Int](repeating: 1, count: count)\n          for i in 0..&lt;count { p[i] = i }\n      }\n  \n      func find(_ i: Int) -> Int {\n          var i = i \n          while i != p[i] {\n              p[i] = p[p[i]]\n              i = p[i]\n          }\n          return i\n      }\n      /// O(1)\n      func find1(_ i: Int) -> Int {// 路径压缩\n          var root = i ,i = i\n          while p[root] != root { root = p[root] }\n          while p[i] != i {\n              let x = i\n              i = p[i]\n              p[x] = root\n          }\n          return root\n      }\n      /// O(n) or O(logn)\n      func union(_ i: Int, _ j: Int) {\n          let pi = find(i), pj = find(j)\n          if pi == pj { return }\n          if size[pi] &lt; size[pj] {\n              p[pi] = pj\n              size[pj] += size[pi]\n          }else {\n              p[pj] = pi\n              size[pi] += size[pj]\n          }\n          count -= 1\n      }\n  }\n</code></pre>"},{"t":"list_item","d":4,"v":"Java 实现"},{"t":"list_item","d":4,"v":"<pre><code class=\"language-java\">  class UnionFind { \n      private int count = 0; \n      private int[] parent; \n      public UnionFind(int n) { \n          count = n; \n          parent = new int[n]; \n          for (int i = 0; i &lt; n; i++) { \n              parent[i] = i;\n          }\n      } \n      public int find(int p) { \n          while (p != parent[p]) { \n              parent[p] = parent[parent[p]]; \n              p = parent[p]; \n          }\n          return p; \n      }\n      public void union(int p, int q) { \n          int rootP = find(p); \n          int rootQ = find(q); \n          if (rootP == rootQ) return; \n          parent[rootP] = rootQ; \n          count--;\n      }\n  }\n</code></pre>"},{"t":"list_item","d":4,"v":"Python 实现"},{"t":"list_item","d":4,"v":"<pre><code class=\"language-python\">  def init(p): \n      # for i = 0 .. n: p[i] = i; \n      p = [i for i in range(n)] \n   \n  def union(self, p, i, j): \n      p1 = self.parent(p, i) \n      p2 = self.parent(p, j) \n      p[p1] = p2 \n   \n  def parent(self, p, i): \n      root = i \n      while p[root] != root: \n          root = p[root] \n      while p[i] != i: # 路径压缩 ?\n          x = i; i = p[i]; p[x] = root \n      return root\n</code></pre>"}]}]},{"t":"heading","d":2,"v":"21、高级搜索（High-Level Search）","c":[{"t":"list_item","d":3,"v":"<strong>I. 剪枝</strong>","c":[{"t":"list_item","d":4,"v":"优化掉重复的，或次优的分支"}]},{"t":"list_item","d":3,"v":"<strong>II. 双向</strong><code><strong>BFS</strong></code><strong>（</strong><code><strong>Two-Ended BFS</strong></code><strong>）</strong>","c":[{"t":"list_item","d":4,"v":"特性","c":[{"t":"list_item","d":5,"v":"左右相向扩散"},{"t":"list_item","d":5,"v":"循环条件是两个queue同时判断（两个set）"},{"t":"list_item","d":5,"v":"每次从小的set扩散"}]},{"t":"list_item","d":4,"v":"代码模版","c":[{"t":"list_item","d":5,"v":"Swift 实现"},{"t":"list_item","d":5,"v":"<pre><code class=\"language-swift\">  var beginSet = Set&lt;String>()\n  var endSet = Set&lt;String>()\n  var visited = Set&lt;String>()\n  \n  beginSet.update(with: begin)\n  endSet.update(with: end)\n\n  while !beginSet.isEmpty, !endSet.isEmpty {\n      if beginSet.count > endSet.count  { \n          (beginSet, endSet) = (endSet, beginSet)\n          //swap(&amp;beginSet, &amp;endSet)\n      }\n      \n      var nextSet = Set&lt;String>()\n      \n      process(beginSet, nextSet, visited)\n      \n      beginSet = nextSet\n  }\n</code></pre>"}]}]},{"t":"list_item","d":3,"v":"<strong>III. 启发式搜索（</strong><code><strong>A*</strong></code><strong>）（</strong><code><strong>Heuristic Search</strong></code><strong>）</strong>","c":[{"t":"list_item","d":4,"v":"估价函数(启发式函数) -> <code>h(n)</code>","c":[{"t":"list_item","d":5,"v":"用来评价哪些结点是我们最有希望寻找的结点"},{"t":"list_item","d":5,"v":"会返回一个非负实数"},{"t":"list_item","d":5,"v":"也可以认为是从 结点n 到 目标结点 路径的估计成本"}]},{"t":"list_item","d":4,"v":"特性","c":[{"t":"list_item","d":5,"v":"是一种告知搜索方向的方法"},{"t":"list_item","d":5,"v":"提供了一种明智的方法来猜测那个邻居结点会导向一个目标"}]},{"t":"list_item","d":4,"v":"代码模版","c":[{"t":"list_item","d":5,"v":"Python 实现"},{"t":"list_item","d":5,"v":"<pre><code class=\"language-python\">  def AstarSearch(graph, start, end):\n      pq = collections.priority_queue() # 优先级 —> 估价函数\n      pq.append([start]) \n      visited.add(start)\n      while pq: \n          node = pq.pop() # can we add more intelligence here ?\n          visited.add(node)\n          process(node) \n          nodes = generate_related_nodes(node) \n     unvisited = [node for node in nodes if node not in visited]\n          pq.push(unvisited)\n</code></pre>"}]}]}]},{"t":"heading","d":2,"v":"22、平衡二叉树 （Self-balancing Binary Search Tree）","c":[{"t":"bullet_list","d":3,"v":"","c":[{"t":"list_item","d":4,"v":"<strong>I. 前置场景</strong>","c":[{"t":"list_item","d":5,"v":"1、保证二维维度 -> 左右子树结点平衡（<code>recursively</code>）"},{"t":"list_item","d":5,"v":"2、<code>balance</code>"}]},{"t":"list_item","d":4,"v":"<strong>II. 具体实现</strong>","c":[{"t":"list_item","d":5,"v":"<code>2-3 Tree</code>"},{"t":"list_item","d":5,"v":"<code>AVL Tree</code>"},{"t":"list_item","d":5,"v":"<code>B- Tree</code> （B树）"},{"t":"list_item","d":5,"v":"<code>Red-black Tree</code> （红黑树）"},{"t":"list_item","d":5,"v":"<code>Splay Tree</code> （伸展树）"},{"t":"list_item","d":5,"v":"<code>Treap</code> （树堆）"}]},{"t":"list_item","d":4,"v":"<strong>III. 平衡二叉搜索树 之 AVL树</strong>","c":[{"t":"list_item","d":5,"v":"1、发明者 G.M.Adelson-Velsky 和 Evgenii Landis"},{"t":"list_item","d":5,"v":"<strong>2、</strong><code><strong>balance Factor</strong></code><strong> （平衡因子）</strong>","c":[{"t":"list_item","d":6,"v":"每个结点的平衡因子都是 <code><strong>{-1, 0, 1}</strong></code>"},{"t":"list_item","d":6,"v":"左子树的高度 减去 右子树的高度（有时相反）"},{"t":"list_item","d":6,"v":"由来：查询的时间复杂度是树的深度"}]},{"t":"list_item","d":5,"v":"3、通过旋转操作进行平衡","c":[{"t":"list_item","d":6,"v":"1)、基础旋转","c":[{"t":"list_item","d":7,"v":"左旋： 子树形态 -> 右右子树<br/>"},{"t":"list_item","d":7,"v":"右旋： 子树形态 -> 左左子树<br/>"},{"t":"list_item","d":7,"v":"左右旋：子树形态 -> 左右子树<br/><br/>"}]}]}]}]},{"t":"bullet_list","d":3,"v":"","c":[{"t":"list_item","d":4,"v":"<strong>IV. 近似平衡二叉搜索树 之 红黑树</strong>","c":[{"t":"list_item","d":5,"v":"1、是一种近似平衡二叉搜索树"},{"t":"list_item","d":5,"v":"2、它能确保任何一个结点的左右子树的<strong>高度差小于两倍</strong>"},{"t":"list_item","d":5,"v":"3、特性 -> 满足如下特性的二叉搜索树","c":[{"t":"list_item","d":6,"v":"1）、每个结点要么是红色，要么是黑色"},{"t":"list_item","d":6,"v":"2）、根结点是黑色"},{"t":"list_item","d":6,"v":"3）、每个叶结点（NIL结点，空结点）是黑色"},{"t":"list_item","d":6,"v":"4）、不能有相邻接的两个红色结点"},{"t":"list_item","d":6,"v":"5）、从任一结点到其每个叶子所有路径都包含相同数目的黑色结点"}]},{"t":"list_item","d":5,"v":"<strong>4、时间复杂度： </strong><code><strong>O(logn)</strong></code>"},{"t":"list_item","d":5,"v":"<strong>5、关键性质：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</strong><br/>"}]},{"t":"list_item","d":4,"v":"<strong>V. AVL树和红黑树对比</strong>","c":[{"t":"list_item","d":5,"v":"AVL trees provide <strong>faster lookups</strong> than Red Black Trees because they are <strong>more strictly balanced</strong>.(<strong>AVL 比 红黑树 查询快， 因为AVL是更加严格平衡的</strong>)"},{"t":"list_item","d":5,"v":"Red Black Trees provide <strong>faster insertion and removal</strong> operations than AVL trees as fewer rotations are done due to relatively relaxed balancing.(<strong>红黑树 比 AVL 插入和删除快， 因为红黑树旋转操作少一点，AVL旋转操作多一点</strong>)"},{"t":"list_item","d":5,"v":"AVL trees store balance <strong>factors or heights</strong> with each node, thus requires storage for an integer per node whereas Red Black Trees requires only 1 bit of information per node.（<strong>AVL 需要额外的内存存储factor和height， 红黑树只需要1个bit存储0或者1来表示红或者黑</strong>）"},{"t":"list_item","d":5,"v":"Red Black Trees are used in most of the <strong>language libraries like map, multimap, multisetin C++</strong> whereas AVL trees are used in <strong>databases</strong> where faster retrievals are required. （<strong>红黑树一般用在高级语言的库里面，AVL一般用在DB多,因为查询多</strong>）"}]}]}]},{"t":"heading","d":2,"v":"23、位运算（Bit Operation）","c":[{"t":"list_item","d":3,"v":"<strong>I. 位运算符</strong>","c":[{"t":"list_item","d":4,"v":"左移：<code>&lt;&lt;</code>","c":[{"t":"list_item","d":5,"v":"示例：0011 -> 0110"}]},{"t":"list_item","d":4,"v":"右移：<code>>></code>","c":[{"t":"list_item","d":5,"v":"示例：0110 -> 0011"}]},{"t":"list_item","d":4,"v":"按位或：<code>|</code>","c":[{"t":"list_item","d":5,"v":"示例：0011 | 1011 -> 1011"}]},{"t":"list_item","d":4,"v":"按位与：<code>&amp;</code>","c":[{"t":"list_item","d":5,"v":"示例：0011 &amp; 1011 -> 0011"}]},{"t":"list_item","d":4,"v":"按位取反：<code>～</code>","c":[{"t":"list_item","d":5,"v":"示例：0011 -> 1100"}]},{"t":"list_item","d":4,"v":"按位异或：<code>^</code>  （<strong>相同为零不同为一</strong>）","c":[{"t":"list_item","d":5,"v":"示例：0011 ^ 1011 -> 1000"},{"t":"list_item","d":5,"v":"异或操作特点：","c":[{"t":"list_item","d":6,"v":"1、<code><strong>x ^ 0 = x</strong></code>"},{"t":"list_item","d":6,"v":"2、<code><strong>x ^ 1s = ~x</strong></code> // 1s = ~0，即1s是表示全为1"},{"t":"list_item","d":6,"v":"3、<code><strong>x ^ (~x) = 1s</strong></code>"},{"t":"list_item","d":6,"v":"4、<code><strong>x ^ x = 0</strong></code>"},{"t":"list_item","d":6,"v":"5、<code><strong>c = a ^ b, b = a ^ c, a = b ^ c</strong></code> // 交换两个数"},{"t":"list_item","d":6,"v":"6、<code><strong>a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c</strong></code> // 满足结合法"}]}]}]},{"t":"list_item","d":3,"v":"<strong>II. 指定位置的位运算</strong>","c":[{"t":"list_item","d":4,"v":"<strong>1、将x最右边的n位清零：</strong><code><strong>x &amp; (~0 &lt;&lt; n)</strong></code>"},{"t":"list_item","d":4,"v":"<strong>2、获取x的第n位值（0或者1）：</strong><code><strong>(x >> n) &amp; 1</strong></code>"},{"t":"list_item","d":4,"v":"<strong>3、获取x的第n位幂值：</strong><code><strong>x &amp; (1 &lt;&lt; n)</strong></code>"},{"t":"list_item","d":4,"v":"<strong>4、仅将第n位置为1：</strong><code><strong>x | (1 &lt;&lt; n)</strong></code>"},{"t":"list_item","d":4,"v":"<strong>5、仅将第n位置为0：</strong><code><strong>x &amp; (~(1 &lt;&lt; n))</strong></code>"},{"t":"list_item","d":4,"v":"<strong>6、将x的最高位至第n位（含）清零：</strong><code><strong>x &amp; ((1 &lt;&lt; n) - 1)</strong></code>"}]},{"t":"list_item","d":3,"v":"<strong>III. 实战位运算要点</strong>","c":[{"t":"list_item","d":4,"v":"<strong>1、判断奇偶</strong>","c":[{"t":"list_item","d":5,"v":"<code><strong>x &amp; 1 == 1</strong></code><strong> -> 奇数 &lt;==> </strong><code><strong>x % 2 == 1</strong></code>"},{"t":"list_item","d":5,"v":"<code><strong>x &amp; 1 == 0</strong></code><strong> -> 偶数 &lt;==> </strong><code><strong>x % 2 == 0</strong></code>"}]},{"t":"list_item","d":4,"v":"<strong>2、除2</strong>","c":[{"t":"list_item","d":5,"v":"<code><strong>x >> 1</strong></code><strong> &lt;==> </strong><code><strong>x / 2</strong></code>"}]},{"t":"list_item","d":4,"v":"<strong>3、清零最低位的1</strong>","c":[{"t":"list_item","d":5,"v":"<code><strong>x = x &amp; (x - 1)</strong></code>"}]},{"t":"list_item","d":4,"v":"<strong>4、</strong><code><strong>x &amp; (-x)</strong></code><strong> ==> 最低位的1所表示的整数</strong>","c":[{"t":"list_item","d":5,"v":"保留最后一位1，而其他位都会清零"},{"t":"list_item","d":5,"v":"x为奇数时，结果一定是1"}]},{"t":"list_item","d":4,"v":"<strong>5、</strong><code><strong>x &amp; (~x)</strong></code><strong> ==> 0</strong>"}]}]},{"t":"heading","d":2,"v":"24、布隆过滤器（Bloom Filter）","c":[{"t":"list_item","d":3,"v":"<strong>I. 原理</strong>","c":[{"t":"list_item","d":4,"v":"一个很长的二进制向量和一系列随机映射函数"},{"t":"list_item","d":4,"v":"添加元素：","c":[{"t":"list_item","d":5,"v":"将要添加的元素给k个哈希函数"},{"t":"list_item","d":5,"v":"得到对应于位数组上的k个位置"},{"t":"list_item","d":5,"v":"将这k个位置设为1"}]},{"t":"list_item","d":4,"v":"查询元素：","c":[{"t":"list_item","d":5,"v":"将要查询的元素给k个哈希函数"},{"t":"list_item","d":5,"v":"得到对应于位数组上的k个位置"},{"t":"list_item","d":5,"v":"如果k个位置有一个为0，则肯定不在集合中"},{"t":"list_item","d":5,"v":"如果k个位置全部为1，则可能在集合中"}]},{"t":"list_item","d":4,"v":""}]},{"t":"list_item","d":3,"v":"<strong>II. 特点</strong>","c":[{"t":"list_item","d":4,"v":"用于检索一个元素是否在一个集合中（<strong>模糊查询</strong>）"},{"t":"list_item","d":4,"v":"优点：空间效率和查询时间都远远超过一般算法"},{"t":"list_item","d":4,"v":"缺点：有一定的误识别率和删除困难"}]},{"t":"list_item","d":3,"v":"<strong>III. 代码实现</strong>","c":[{"t":"list_item","d":4,"v":"<pre><code class=\"language-swift\">  class BloomFilter {\n      var size: Int\n      var array: [Bool]\n      var hash_num: Int\n      init(_ size: Int = 1024, _ hash_num: Int) {\n          self.size = size\n          self.hash_num = hash_num\n          array = [Bool](repeating: false, count: size)\n      }\n      \n      func add(_ s: String) {\n          for h in 0..&lt;hash_num {\n              let index = abs(hashFunc(s, h) % array.count)\n              array[index] = true\n          }\n      }\n      /// 返回false一定不存在，返回true可能存在\n      func lookup(_ s: String) -> Bool {\n          for h in 0..&lt;hash_num {\n              let index = abs(hashFunc(s, h) % array.count)\n              if !array[index] { return false }\n          }\n          return true\n      }\n      func hashFunc(_ x: String, _ n: Int) -> Int {\n          var hash = n\n          for char in x {\n              hash = char.hashValue &amp;+ (hash &lt;&lt; 6) &amp;+ (hash &lt;&lt; 16) &amp;- hash\n          }\n          return Int(hash)\n      }\n      /* Two hash functions, adapted from http://www.cse.yorku.ca/~oz/hash.html */\n  \n      func djb2(x: String) -> Int {\n        var hash = 5381\n        for char in x {\n          hash = ((hash &lt;&lt; 5) &amp;+ hash) &amp;+ char.hashValue\n        }\n        return Int(hash)\n      }\n  \n      func sdbm(x: String) -> Int {\n        var hash = 0\n        for char in x {\n          hash = char.hashValue &amp;+ (hash &lt;&lt; 6) &amp;+ (hash &lt;&lt; 16) &amp;- hash\n        }\n        return Int(hash)\n      }\n  }\n</code></pre>"}]}]},{"t":"heading","d":2,"v":"25、LRU Cache","c":[{"t":"list_item","d":3,"v":"<strong>I. 基本特性</strong>","c":[{"t":"list_item","d":4,"v":"1、缓存大小"},{"t":"list_item","d":4,"v":"2、替换策略","c":[{"t":"list_item","d":5,"v":"<code>LRU</code>：<code>Least recently used</code> 最近最少使用"},{"t":"list_item","d":5,"v":"<code>LFU</code>：<code>least frequently used</code> 最近最常使用"}]}]},{"t":"list_item","d":3,"v":"<strong>II. 实现示例</strong>","c":[{"t":"list_item","d":4,"v":"哈希表<code>Hash Table</code> + 双向链表<code>Double LinkedList</code>"},{"t":"list_item","d":4,"v":"<strong>查询时间复杂度： </strong><code><strong>O(1)</strong></code><strong> -> 哈希表</strong>"},{"t":"list_item","d":4,"v":"<strong>修改更新时间复杂度：</strong><code><strong>O(1)</strong></code><strong> -> 双向链表</strong>"},{"t":"list_item","d":4,"v":""}]},{"t":"list_item","d":3,"v":"代码实现","c":[{"t":"list_item","d":4,"v":"Swift 实现"},{"t":"list_item","d":4,"v":"<pre><code class=\"language-swift\">  class Node {\n      var key: Int\n      var val: Int\n      var prev: Node?\n      var next: Node?\n      init(_ key: Int = 0, _ val: Int = 0, _ prev: Node? = nil, _ next: Node? = nil){\n          self.key = key\n          self.val = val\n          self.prev = prev\n          self.next = next\n      }\n  }\n  \n  class DLinked {\n      private var head: Node\n      private var tail: Node\n      var size = 0\n      init() {\n          head = Node()\n          tail = Node()\n          head.next = tail\n          tail.prev = head\n      }\n  \n      func insertFirst(_ node: Node) {\n          let cur = head.next\n          head.next = node\n          node.prev = head\n          node.next = cur\n          cur?.prev = node\n          size += 1\n      }\n      func remove(_ node: Node) {\n          node.next?.prev = node.prev\n          node.prev?.next = node.next\n          size -= 1\n      }\n      func remodeLast() -> Node? {\n          guard let node = tail.prev, size > 0 else { return nil }\n          remove(node)\n          return node\n      }\n  }\n  class LRUCache {\n  \n      var capacity: Int\n      var container = [Int: Node]()\n      var dLinked = DLinked()\n  \n      init(_ capacity: Int) {\n          self.capacity = capacity\n      }\n      \n      func get(_ key: Int) -> Int {\n          if let node = container[key] {\n              dLinked.remove(node)\n              dLinked.insertFirst(node)\n              return node.val\n          }\n          return -1\n      }\n      \n      func put(_ key: Int, _ value: Int) {\n          if let node = container[key] {\n              dLinked.remove(node)\n          }\n          let newNode = Node(key, value)\n          dLinked.insertFirst(newNode)\n          container[key] = newNode\n          if dLinked.size > capacity, let node = dLinked.remodeLast() {\n              container.removeValue(forKey: node.key)\n          }\n      }\n  }\n</code></pre>"}]}]},{"t":"heading","d":2,"v":"26、排序算法（Sort）","c":[{"t":"bullet_list","d":3,"v":"","c":[{"t":"paragraph","d":4,"v":"<strong>I. 算法分类</strong>"},{"t":"bullet_list","d":4,"v":"","c":[{"t":"list_item","d":5,"v":"1、比较类排序","c":[{"t":"list_item","d":6,"v":"通过比较决定元素之间的相对次序，由于其时间复杂度不能超过<code>O(nlogn)</code>，因此其也称为非线形时间比较类排序"}]},{"t":"list_item","d":5,"v":"2、非比较类排序","c":[{"t":"list_item","d":6,"v":"不能通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线形时间运行，因此也称为线形时间费比较类排序"}]},{"t":"list_item","d":5,"v":""}]}]},{"t":"bullet_list","d":3,"v":"","c":[{"t":"list_item","d":4,"v":"<strong>II. 复杂度分析</strong>","c":[{"t":"bullet_list","d":5,"v":"","c":[{"t":"paragraph","d":6,"v":""}]},{"t":"blockquote","d":5,"v":"","c":[{"t":"paragraph","d":6,"v":"稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面.<br/>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面."}]}]},{"t":"list_item","d":4,"v":"<strong>III. 初级排序</strong> - <code>O(n^2)</code>","c":[{"t":"list_item","d":5,"v":"选择排序（Selection Sort）","c":[{"t":"list_item","d":6,"v":"每次找最小值，然后放在待排序数组的起始位置"}]},{"t":"list_item","d":5,"v":"插入排序（Insertion Sort）","c":[{"t":"list_item","d":6,"v":"从前到后逐步构建有序序列"},{"t":"list_item","d":6,"v":"对于未排序数据，在已排序序列中，从后向前扫描，找到相应位置并插入"}]},{"t":"list_item","d":5,"v":"冒泡排序（Bubble Sort）","c":[{"t":"list_item","d":6,"v":"嵌套循环，每次查看相邻元素，如果逆序，则交换"}]},{"t":"list_item","d":5,"v":"希尔排序（Shell Sort） - <code>O(n^1.3)</code>","c":[{"t":"list_item","d":6,"v":"是简单插入排序的改进版"},{"t":"list_item","d":6,"v":"它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。"}]}]},{"t":"list_item","d":4,"v":"<strong>IV. 高级排序</strong> - <code>O(nlogn)</code>","c":[{"t":"list_item","d":5,"v":"快速排序（Quick Sort）","c":[{"t":"list_item","d":6,"v":"数组取标杆pivot，将小元素放在pivot左边，大元素放在pivot右边"},{"t":"list_item","d":6,"v":"然后依次对左边和右边的子数组快速排序，以达到整个序列有序"}]},{"t":"list_item","d":5,"v":"归并排序（Merge Sort） - 分治","c":[{"t":"list_item","d":6,"v":"把长度为n的输入序列分成两个长度为2/n的子序列"},{"t":"list_item","d":6,"v":"对这两个子序列分别进行归并排序"},{"t":"list_item","d":6,"v":"将两个排序好的子序列合并成最终的一个排序序列"}]},{"t":"list_item","d":5,"v":"堆排序（Heap Sort） - 插入：<code>O(logn)</code>, 取最大值或最小值：<code>O(1)</code>","c":[{"t":"list_item","d":6,"v":"数组元素依次建立小顶堆或大顶堆"},{"t":"list_item","d":6,"v":"依次取堆顶元素，并删除"}]}]},{"t":"list_item","d":4,"v":"<strong>V 特殊排序</strong> - <code>O(n)</code>","c":[{"t":"list_item","d":5,"v":"计数排序（Counting Sort）","c":[{"t":"list_item","d":6,"v":"要求输入的数据是有范围的整数"},{"t":"list_item","d":6,"v":"将输入的数据值转化为键存储在额外开辟的数组空间中"},{"t":"list_item","d":6,"v":"然后依次把计数大于1的值填回原数组中"}]},{"t":"list_item","d":5,"v":"桶排序（Bucket Sort）","c":[{"t":"list_item","d":6,"v":"假设输入数据服从均匀分布"},{"t":"list_item","d":6,"v":"将数据分布到有限数量的桶里，每个桶再分别排序（使用其他排序算法或递归继续桶排序）"}]},{"t":"list_item","d":5,"v":"基数排序（Radix Sort）","c":[{"t":"list_item","d":6,"v":"低位先排序，然后收集"},{"t":"list_item","d":6,"v":"高位再排序，然后收集"},{"t":"list_item","d":6,"v":"依次类推，直到最高位"},{"t":"list_item","d":6,"v":"有优先级顺序的，先按低优先级排序，再按高优先级排序"}]}]},{"t":"list_item","d":4,"v":"<strong>VI. 代码示例</strong>","c":[{"t":"bullet_list","d":5,"v":"","c":[{"t":"list_item","d":6,"v":"冒泡排序"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">  func bubbleSort(_ nums: [Int]) -> [Int] {\n      var nums = nums\n      for i in 0..&lt;nums.count - 1 {\n          for j in 0..&lt;nums.count - i - 1 {\n              if nums[j] > nums[j + 1] {\n                  (nums[j], nums[j + 1]) = (nums[j + 1], nums[j])\n              }\n          }\n      }\n      return nums\n  }\n</code></pre>"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">  func bubbleSort1(_ nums: [Int]) -> [Int] {\n      \n      var nums = nums\n      for i in 0..&lt;nums.count - 1 {\n          for j in i + 1..&lt;nums.count {\n              if nums[i] > nums[j] {\n                  (nums[i], nums[j]) = (nums[j], nums[i])\n              }\n          }\n      }\n      return nums\n  }\n</code></pre>"},{"t":"list_item","d":6,"v":"选择排序"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">  func selectionSort(_ nums: [Int]) -> [Int] {\n      var nums = nums\n      for i in 0..&lt;nums.count - 1 {\n          var min = i\n          for j in i + 1..&lt;nums.count {\n              if nums[min] > nums[j] {\n                  min = j\n              }\n          }\n          (nums[i], nums[min]) = (nums[min], nums[i])\n      }\n      return nums\n  }\n</code></pre>"},{"t":"list_item","d":6,"v":"插入排序"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">  func insertionSort(_ nums: [Int]) -> [Int] {\n      var nums = nums\n      for i in 1..&lt;nums.count {\n          var j = i\n          while j > 0, nums[j] &lt; nums[j - 1] {\n              (nums[j], nums[j - 1]) = (nums[j - 1], nums[j])\n              j -= 1\n          }\n      }\n      return nums\n  }\n</code></pre>"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">  func insertionSort1(_ nums: [Int]) -> [Int] {\n      \n      var nums = nums\n      for i in 1..&lt;nums.count {\n          var j = i, temp = nums[i]\n          while j > 0, temp &lt; nums[j - 1] {\n              nums[j] = nums[j - 1]\n              j -= 1\n          }\n          nums[j] = temp\n      }\n      return nums\n  }\n</code></pre>"},{"t":"list_item","d":6,"v":"希尔排序"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">  func shellSort(_ nums: [Int]) -> [Int] {\n      var nums = nums, gap = nums.count >> 1\n      while gap > 0 {\n          for i in gap..&lt;nums.count {\n              var j = i\n              while j - gap >= 0, nums[j] &lt; nums[j - gap] {\n                  (nums[j], nums[j - gap]) = (nums[j - gap], nums[j])\n                  j -= gap\n              }\n          }\n          gap >>= 1\n      }\n      return nums\n  }\n</code></pre>"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">  func shellSort1(_ nums: [Int]) -> [Int] {\n      \n      var nums = nums, gap = nums.count >> 1\n      while gap > 0 {\n          for i in gap..&lt;nums.count {\n              var j = i, temp = nums[i]\n              while j - gap >= 0, temp &lt; nums[j - gap] {\n                  nums[j] = nums[j - gap]\n                  j -= gap\n              }\n              nums[j] = temp\n          }\n          gap >>= 1\n      }\n      return nums\n  }\n</code></pre>"},{"t":"list_item","d":6,"v":"归并排序"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">  func mergeSort(_ nums: [Int]) -> [Int] {\n      guard nums.count > 1 else { return nums }\n      var nums = nums\n      let mid = nums.count >> 1\n      return merge(mergeSort(Array(nums[0..&lt;mid])), mergeSort(Array(nums[mid...])))\n  \n  }\n  func merge(_ nums1: [Int], _ nums2: [Int]) -> [Int] {\n      var res = [Int](), nums1 = nums1, nums2 = nums2\n      while nums1.count > 0, nums2.count > 0 {\n          if nums1[0] &lt;= nums2[0] { res.append(nums1.removeFirst()) }\n          else { res.append(nums2.removeFirst()) }\n      }\n      while nums1.count > 0 { res.append(nums1.removeFirst()) }\n      while nums2.count > 0 { res.append(nums2.removeFirst()) }\n      return res\n  }\n</code></pre>"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">  func mergeSort1(_ nums: inout [Int], _ left: Int, _ right: Int) {\n      \n      if right &lt;= left { return }\n      let mid = (left + right) >> 1\n      mergeSort1(&amp;nums, left, mid)\n      mergeSort1(&amp;nums, mid + 1, right)\n      merge1(&amp;nums, left, right, mid)\n  }\n  func merge1(_ nums: inout [Int], _ left: Int, _ right: Int, _ mid: Int) {\n      var res = [Int]() // right - left + 1\n      var i = left, j = mid + 1\n      while i &lt;= mid, j &lt;= right {\n          if nums[i] &lt; nums[j] { res += [nums[i]]; i += 1 }\n          else { res += [nums[j]]; j += 1 }\n      }\n      while i &lt;= mid { res += [nums[i]]; i += 1}\n      while j &lt;= right {res += [nums[j]]; j += 1 }\n      for p in 0..&lt;res.count { nums[left + p] = res[p] }\n  }\n</code></pre>"},{"t":"list_item","d":6,"v":"快速排序"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">  func quickSort(_ nums: inout [Int], _ left: Int, _ right: Int) {\n      if left >= right { return }\n      var i = left, j = right, pivot = nums[left]\n      while i &lt; j {\n          while i &lt; j, nums[j] >= pivot { j -= 1 }\n          while i &lt; j, nums[i] &lt;= pivot { i += 1 }\n          if i &lt; j { (nums[i], nums[j]) = (nums[j], nums[i]) }\n      }\n      (nums[left], nums[i]) = (nums[i], pivot)\n  \n      quickSort(&amp;nums, left, i - 1)\n      quickSort(&amp;nums, i + 1, right)\n  }\n</code></pre>"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">  func quickSort1(_ nums: inout [Int], _ left: Int, _ right: Int) {\n     \n      if left >= right { return }\n  //    var i = left, pivot = nums[right]\n  //    for j in left..&lt;right {\n  //        if nums[j] &lt; pivot {\n  //            (nums[j], nums[i]) = (nums[i], nums[j])\n  //            i += 1\n  //        }\n  //    }\n  //    (nums[right], nums[i]) = (nums[i], pivot)\n      var i = left, pivot = nums[left]\n      for j in left+1...right {\n          if nums[j] &lt; pivot {\n              i += 1\n              (nums[j], nums[i]) = (nums[i], nums[j])\n          }\n      }\n      (nums[left], nums[i]) = (nums[i], pivot)\n      quickSort1(&amp;nums, left, i - 1)\n      quickSort1(&amp;nums, i + 1, right)\n  }\n</code></pre>"},{"t":"list_item","d":6,"v":"堆排序"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">  func heapSort(_ nums: inout [Int]) {\n      for i in (0..&lt;nums.count >> 1).reversed() {\n          heapif1(&amp;nums, i, nums.count)\n      }\n  \n      for i in (0..&lt;nums.count).reversed() {\n          nums.swapAt(0, i)\n          heapif1(&amp;nums, 0, i)\n      }\n  }\n  \n  func heapif(_ nums: inout [Int], _ i: Int, _ length: Int) {\n      let left = 2 * i + 1, right = 2 * i + 2\n      var lagest = i\n      if left &lt; length, nums[lagest] &lt; nums[left] { lagest = left }\n      if right &lt; length, nums[lagest] &lt; nums[right] { lagest = right }\n      if lagest != i {\n          (nums[lagest], nums[i]) = (nums[i], nums[lagest])\n          heapif(&amp;nums, lagest, length)\n      }\n  }\n  func heapif1(_ nums: inout [Int], _ i: Int, _ length: Int) {\n      var lagest = i, k = 2 * i + 1\n      let temp = nums[i]\n      while k &lt; length {\n          if k + 1 &lt; length, nums[k] &lt; nums[k + 1] { k += 1 }\n          if nums[k] &lt;= temp { break }\n          else { nums[lagest] = nums[k]; lagest = k }\n          k = 2 * k + 1\n      }\n      nums[lagest] = temp\n</code></pre>"}]},{"t":"bullet_list","d":5,"v":"","c":[{"t":"list_item","d":6,"v":"计数排序"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">  func countingSort(_ nums: [Int]) -> [Int] {\n      var res = [Int](), maxVal = nums.max()\n      var counters = [Int](repeating: 0, count: maxVal! + 1)\n      for i in 0..&lt;nums.count {\n          counters[nums[i]] += 1\n      }\n      for i in 0..&lt;counters.count {\n          while counters[i] > 0 {\n              res += [i]\n              counters[i] -= 1\n          }\n      }\n      return res\n  }\n</code></pre>"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">  func countingSort1(_ nums: [Int]) -> [Int] {\n      \n      var res = nums, maxVal = nums.max()\n      var counters = [Int](repeating: 0, count: maxVal! + 1)\n      for i in 0..&lt;nums.count {\n          counters[nums[i]] += 1\n      }\n      for i in 1..&lt;counters.count {\n          counters[i] += counters[i - 1]\n      }\n      for n in nums {\n          counters[n] -= 1\n          res[counters[n]] = n\n      }\n      return res\n  }\n</code></pre>"},{"t":"list_item","d":6,"v":"桶排序"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">  func bucketSort(_ nums: [Int], _ gap: Int) -> [Int] {\n      var res = [Int]()\n      let minVal = nums.min()!, maxVal = nums.max()!\n      let gap = gap > 0 ? gap : 5\n      let bucketCount = (maxVal - minVal) / gap + 1\n      var buckets = [[Int]](repeating: [Int](), count: bucketCount)\n      for i in 0..&lt;nums.count {\n          let idx = (nums[i] - minVal) / gap\n          buckets[idx] += [nums[i]]\n      }\n      for i in 0..&lt;bucketCount {\n          res += buckets[i].sorted() // 可以使用其他排序方式\n      }\n      return res\n  }\n</code></pre>"},{"t":"list_item","d":6,"v":"基数排序"},{"t":"list_item","d":6,"v":"<pre><code class=\"language-swift\">  func radixSort(_ nums: inout [Int]) {\n      var mod = 10, dev = 1\n      var done = false\n      while !done {\n          done = true\n          var buckets = [[Int]](repeating: [Int](), count: mod)\n          for i in 0..&lt;nums.count {\n              let idx = nums[i] / dev\n              buckets[idx % mod].append(nums[i])\n              if done, idx > 0 { done = false }\n          }\n  \n          var j = 0\n          for i in 0..&lt;mod {\n              for n in buckets[i] {\n                  nums[j] = n\n                  j += 1\n              }\n          }\n          dev *= 10\n      }\n  }\n</code></pre>"}]}]}]}]},{"t":"heading","d":2,"v":"27、字符串算法（String）","c":[{"t":"list_item","d":3,"v":"<strong>I. 字符串基本知识</strong>","c":[{"t":"list_item","d":4,"v":"可变字符串和不可变字符串"},{"t":"list_item","d":4,"v":"字符串的比较"}]},{"t":"list_item","d":3,"v":"<strong>II. 高级字符串算法</strong>","c":[{"t":"list_item","d":4,"v":"结合动态规划","c":[{"t":"list_item","d":5,"v":"<code>DP[i][j]</code>: 一般i代表前一个字符串的相对变化，j代表后一个字符串的相对变化"}]}]},{"t":"list_item","d":3,"v":"<strong>III. 字符串匹配算法</strong>","c":[{"t":"list_item","d":4,"v":"暴力法 - <code>O(mn)</code>"},{"t":"list_item","d":4,"v":"<pre><code class=\"language-swift\">  func forceSearch1(_ text: String, _ pat: String) -> Int {\n      let M = text.count, N = pat.count\n      let textA = Array(text), patA = Array(pat)\n      var i = 0, j = 0, k = i\n      while i &lt; M {\n          if textA[k] == patA[j] {\n              k += 1; j += 1\n              if j == N { return i }\n          }else {\n              i += 1; k = i; j = 0\n          }\n      }\n      return -1\n  }\n</code></pre>"},{"t":"list_item","d":4,"v":"<pre><code class=\"language-swift\">  func forceSearch(_ text: String, _ pat: String) -> Int {\n      \n      let M = text.count, N = pat.count\n      let textA = Array(text), patA = Array(pat)\n      for i in 0...M - N {\n  //        var j = 0\n  //        for _ in 0..&lt;N {\n  //            if textA[i + j] != patA[j] { break }\n  //            j += 1\n  //        }\n  //        if j == N { return i }\n          if Array(textA[i..&lt;N+i]) == patA { return i }\n      }\n      return -1\n  }\n</code></pre>"},{"t":"list_item","d":4,"v":"<code>Rabin-Karp</code>算法 - <code>O(m + n)</code>"},{"t":"list_item","d":4,"v":"<pre><code class=\"language-swift\">  func rabinKarpSearch(_ text: String, _ pat: String) -> Int {\n      let D = 256\n      let Q = 9997\n      \n      let M = text.count, N = pat.count\n      let txtA = Array(text), patA = Array(pat)\n      var txtHash = 0, patHash = 0\n      var highestPow = 1 // pow(256, N-1)\n      \n      for i in 0..&lt;N {\n          patHash = (D * patHash + Int(patA[i].asciiValue!)) % Q\n          txtHash = (D * txtHash + Int(txtA[i].asciiValue!)) % Q\n      }\n      \n      for _ in 0..&lt;N - 1 { highestPow = (D * highestPow) % Q }\n      \n      for i in 0...M - N {\n          if patHash == txtHash {\n  //            var isMatch = true\n  //            for j in 0..&lt;N {\n  //                if txtA[i + j] != patA[j] { isMatch = false ; break }\n  //            }\n  //            if isMatch { return i }\n              if Array(txtA[i..&lt;N+i]) == patA { return i }\n          }\n          if i &lt; M - N {\n              txtHash = (D * (txtHash - Int(txtA[i].asciiValue!) * highestPow) + Int(txtA[i + N].asciiValue!)) % Q\n              if txtHash &lt; 0 { txtHash += Q }\n          }\n      }\n      return -1\n  }\n</code></pre>"},{"t":"list_item","d":4,"v":"<code>KMP</code>算法 - <code>O(m + n)</code>"},{"t":"list_item","d":4,"v":"<pre><code class=\"language-swift\">  func prefixTable(_ pattern: String) -> [Int] {\n      guard !pattern.isEmpty else { return [] }\n      let pa = Array(pattern)\n      var prefix = [Int](repeating: 0, count: pa.count)\n      var i = 1, len = 0\n      while i &lt; pa.count {\n          if pa[i] == pa[len] {\n              len += 1\n              prefix[i] = len\n              i += 1\n          }else {\n              if len > 0 { len = prefix[len - 1] }\n              else { prefix[i] = len; i += 1 }\n          }\n      }\n      // 相当于整体向后移动一位，然后在第一位加个-1\n      prefix.insert(-1, at: 0)\n      prefix.removeLast()\n      return prefix\n  }\n  \n  /*\n  a                       0\n  a b                     0\n  a b a                   1\n  a b a b                 2\n  a b a b c               0\n  a b a b c b             0\n  a b a b c b c           0\n  a b a b c b c a         1\n  */\n  \n</code></pre>"},{"t":"list_item","d":4,"v":"<code>Boyer-Moore</code>算法 - <code>O(m/n)</code>"},{"t":"list_item","d":4,"v":"<code>Sunday</code>算法 - <code>O(n)</code>"}]}]}]},(t,a,e)=>t(a,e),["prism"],{"mathJax":false,"prism":true})</script>
</body>
</html>
